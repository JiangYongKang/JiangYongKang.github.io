---
title: 类加载机制与双亲委派
date: 2020-04-14 10:36:06
tags: [Java, JVM]
categories: 服务端开发
---
虚拟机将描述类的数据从字节码文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。类加载器负责将字节码文件中的二进制数据加载到内存中，在运行时数据区的方法区内创建 `Class` 对象，这也是类加载过程的最终产物。类型的加载、链接、初始化的过程都是在程序运行时完成的。

<!-- more -->

### 什么是类加载器？

虚拟机设计团队把类加载阶段中的 **通过一个类的全限定名来获取描述此类的二进制字节流** 这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何获取所需要的类，实现这个动作的代码模块称为 **类加载器**。类加载器虽然只用于实现类的加载动作，但它在 Java 程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 Java 虚拟机中的唯一性。

### 类的生命周期

类从被加载到虚拟机内存中开始，到卸出内存为止，它的整个生命周期包括：`加载、验证、准备、解析、初始化、使用、卸载` 7 个阶段。其中 `验证、准备、解析` 3 个部分统称为链接，这七个阶段的发生顺序如图所示：
![类的声明周期](http://q8nnvv93v.bkt.clouddn.com/117b2df125918f87b14feb857fc567bb.jpeg)

### 加载阶段

**加载** 是类加载过程的一个阶段。在加载阶段，虚拟机需要完成以下三件事情：

1. 通过一个类的完全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 `java.lang.Class` 对象，作为方法区这个类的各种数据的访问入口

### 验证阶段

**验证** 是连接阶段的第一步，这一阶段的目的是为了确保字节码文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。为什么会有这个阶段？因为字节码文件并不一定要求用 Java 源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生字节码文件。验证阶段大致会完成下面 4 个阶段的检验动作：

1. 文件格式验证。这一阶段要验证字节流是否符合字节码文件格式的规范，并且能被当前版本的虚拟机处理。
2. 元数据验证。这一阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。
3. 字节码验证。这一阶段主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
4. 符号引用验证。这一阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段-解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。

### 准备阶段

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的的内存都将在方法区中进行分配。首先，这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。下图是 Java 基本数据类型的初始值：

![基本数据类型的初始值](http://q8nnvv93v.bkt.clouddn.com/607b1d76c15c9eb3566fa54d239bda0f.jpeg)

### 解析阶段

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

### 初始化

类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。

### 什么是双亲委派

从 Java 虚拟机的角度来说，只存在两种不同的类加载器。

1. 一种是启动类加载器 `Bootstrap ClassLoader`。该类加载器使用 C++ 语言实现，属于虚拟机自身的一部分。
2. 一种就是所有其它的类加载器。这些类加载器是由 Java 语言实现，独立于虚拟机外部，并且全部继承自抽象类 `java.lang.ClassLoader`

从 Java 开发人员的角度来看，大部分 Java 程序一般会使用到以下三种系统提供的类加载器：

1. 启动类加载器 `Bootstrap ClassLoader`。负责加载 `<JAVA_HOME>\lib` 目录中并且能被虚拟机识别的类库到虚拟机内存中，如果名称不符合的类库即使放在 lib 目录中也不会被加载。该类加载器无法被 Java 程序直接引用
2. 扩展类加载器 `Extension ClassLoader`。该加载器主要是负责加载 `<JAVA_HOME>\lib\ext`，该加载器可以被开发者直接使用
3. 应用程序类加载器 `Application ClassLoader`。该类加载器也称为系统类加载器，它负责加载用户类路径 `CLASS_PATH` 上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器

下图展示了类加载器之间的这种层次关系。这种模型被称为类加载器的 **双亲委派模型**

![双亲委派模型](http://q8nnvv93v.bkt.clouddn.com/27f3b49f117f5c727b8552d3a6637fcd.jpeg)

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求都最终应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子类加载器才会尝试自己去加载。

### 为什么这么设计？

使用 **双亲委派模型** 来组织类加载器之间的关系，有一个显而易见的好处就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 `java.lang.Object`，它存放在 `rt.jar` 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 `Object` 类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类自行去加载的话，如果用户自己编写了一个 `java.lang.Object` 的类，并放在程序的 `CLASS_PATH` 中，那系统中将会出现多个不同的 `Object` 类，Java 体系同最基础的行为也就无法保证，应用程序也会变得一片混乱。
